 # 🧭 Concept: Two-Pointer Technique

The **two-pointer technique** is used to efficiently find the middle node of a linked list by moving two pointers at different speeds.

---

## 🧩 Idea

We use **two pointers**:

### 🐢 Slow pointer (`slow`)
- Moves **one step at a time** → `slow = slow.next`
- Progresses slowly through the list.

### 🐇 Fast pointer (`fast`)
- Moves **two steps at a time** → `fast = fast.next.next`
- Progresses faster through the list.

---

## ⚙️ How It Works

1. Start both pointers at the **head** of the linked list.  
2. Move:
   - `slow` → one node at a time  
   - `fast` → two nodes at a time  
3. When `fast` reaches the **end of the list** (`fast === null` or `fast.next === null`),  
   → the `slow` pointer will be at the **middle node**.

---

## 🧠 Why It Works

Let the linked list have **n nodes**:

- The `fast` pointer moves **twice as fast** as the `slow` pointer.  
- When `fast` reaches the end:
  - `slow` has moved **half the distance**.
  - Thus, `slow` points to the **middle node**.

For **even-length lists**,  
`slow` will point to the **second middle node** (as required by the problem).

---

## 🧾 Step-by-step Example

### Example 1: Odd-length list

**List:** `1 -> 2 -> 3 -> 4 -> 5`

| Iteration | slow | fast |
|------------|------|------|
| Start      | 1    | 1    |
| 1          | 2    | 3    |
| 2          | 3    | 5    |
| 3          | 3    | null → stop |

**Middle node:** `3` ✅

---

### Example 2: Even-length list

**List:** `1 -> 2 -> 3 -> 4 -> 5 -> 6`

| Iteration | slow | fast |
|------------|------|------|
| Start      | 1    | 1    |
| 1          | 2    | 3    |
| 2          | 3    | 5    |
| 3          | 4    | null → stop |

**Middle node:** `4` (second middle node) ✅

---

## 💻 Code Example

```js
var middleNode = function(head) {
    let slow = head;
    let fast = head;

    while (fast !== null && fast.next !== null) {
        fast = fast.next.next;
        slow = slow.next;
    }

    return slow; // Middle node
};
```
### ✅ Time Complexity: O(n)
### ✅ Space Complexity: O(1)