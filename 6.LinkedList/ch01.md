 # üìò Linked List in JavaScript

## üß© What is a Linked List?

A **Linked List** is a linear data structure where elements (called
**nodes**) are connected using **pointers**.\
Each node contains two parts: 1. **Data** --- The actual value stored in
the node. 2. **Next** --- A pointer/reference to the next node in the
list.

Unlike arrays, linked lists do not store elements in contiguous memory
locations.\
They are ideal for dynamic data structures where frequent insertions or
deletions occur.

------------------------------------------------------------------------

## üß± Types of Linked Lists

### 1. Singly Linked List

Each node points to the next node and the last node points to `null`.

**Structure:**

    [Data | Next] ‚Üí [Data | Next] ‚Üí [Data | null]

**Example (Implementation in JavaScript):**

``` javascript
class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}

class LinkedList {
  constructor() {
    this.head = null;
  }

  // Add node to end
  append(data) {
    const newNode = new Node(data);
    if (!this.head) {
      this.head = newNode;
      return;
    }
    let current = this.head;
    while (current.next) {
      current = current.next;
    }
    current.next = newNode;
  }

  // Display list
  printList() {
    let current = this.head;
    let list = "";
    while (current) {
      list += current.data + " -> ";
      current = current.next;
    }
    console.log(list + "null");
  }
}

// Example usage
const list = new LinkedList();
list.append(10);
list.append(20);
list.append(30);
list.printList(); // Output: 10 -> 20 -> 30 -> null
```

------------------------------------------------------------------------

### 2. Doubly Linked List

Each node contains references to both **previous** and **next** nodes.

**Structure:**

    null ‚Üê [Prev | Data | Next] ‚Üî [Prev | Data | Next] ‚Üí null

**Example (Implementation in JavaScript):**

``` javascript
class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
    this.prev = null;
  }
}

class DoublyLinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
  }

  append(data) {
    const newNode = new Node(data);
    if (!this.head) {
      this.head = newNode;
      this.tail = newNode;
      return;
    }
    this.tail.next = newNode;
    newNode.prev = this.tail;
    this.tail = newNode;
  }

  printForward() {
    let current = this.head;
    let list = "";
    while (current) {
      list += current.data + " ‚Üî ";
    current = current.next;
    }
    console.log("Forward: " + list + "null");
  }

  printBackward() {
    let current = this.tail;
    let list = "";
    while (current) {
      list += current.data + " ‚Üî ";
      current = current.prev;
    }
    console.log("Backward: " + list + "null");
  }
}

// Example usage
const dll = new DoublyLinkedList();
dll.append(5);
dll.append(15);
dll.append(25);
dll.printForward();  // Forward: 5 ‚Üî 15 ‚Üî 25 ‚Üî null
dll.printBackward(); // Backward: 25 ‚Üî 15 ‚Üî 5 ‚Üî null
```

------------------------------------------------------------------------

### 3. Circular Linked List

The **last node** points back to the **head**, forming a circle.

**Structure:**

    [Data | Next] ‚Üí [Data | Next] ‚Üí [Data | Next] ‚Üò
                     ‚Üë______________________________

**Example (Implementation in JavaScript):**

``` javascript
class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}

class CircularLinkedList {
  constructor() {
    this.head = null;
  }

  append(data) {
    const newNode = new Node(data);
    if (!this.head) {
      this.head = newNode;
      newNode.next = this.head;
      return;
    }
    let current = this.head;
    while (current.next !== this.head) {
      current = current.next;
    }
    current.next = newNode;
    newNode.next = this.head;
  }

  printList() {
    if (!this.head) return;
    let current = this.head;
    const values = [];
    do {
      values.push(current.data);
      current = current.next;
    } while (current !== this.head);
    console.log(values.join(" -> ") + " -> (head)");
  }
}

// Example usage
const cll = new CircularLinkedList();
cll.append(1);
cll.append(2);
cll.append(3);
cll.printList(); // Output: 1 -> 2 -> 3 -> (head)
```

------------------------------------------------------------------------

## ‚öôÔ∏è Common Operations in Linked List

  Operation       Description              Time Complexity
  --------------- ------------------------ -----------------
  `append()`      Add node at end          O(n)
  `prepend()`     Add node at start        O(1)
  `delete()`      Delete a specific node   O(n)
  `search()`      Find an element          O(n)
  `printList()`   Display the list         O(n)

------------------------------------------------------------------------

## üß† Advantages of Linked List

‚úÖ Dynamic size (no fixed length like arrays)\
‚úÖ Efficient insertions and deletions\
‚úÖ No memory wastage due to resizing

------------------------------------------------------------------------

## ‚ö†Ô∏è Disadvantages

‚ùå Random access not possible (must traverse)\
‚ùå Extra memory for storing pointers\
‚ùå Sequential access only

------------------------------------------------------------------------

## üß© Real-World Applications

-   Implementing stacks and queues\
-   Browser history (doubly linked list)\
-   Music playlists (circular linked list)\
-   Undo/redo functionality in editors

------------------------------------------------------------------------

## üèÅ Important Point

Linked lists are a fundamental data structure that allow flexible memory
usage and efficient node management.\
Mastering linked lists helps you understand **memory management**,
**dynamic data handling**, and **pointer manipulation** 

# üìä Difference Between Array and Linked List

## üîç Overview

Both **arrays** and **linked lists** are linear data structures used to
store collections of data.\
However, they differ in how they store, access, and manage that data.

------------------------------------------------------------------------

## ‚öôÔ∏è Comparison Table

  | Feature                | Array                                                 | Linked List                                                   |
| ---------------------- | ----------------------------------------------------- | ------------------------------------------------------------- |
| **Memory Allocation**  | Contiguous (elements stored together)                 | Non-contiguous (each node can be anywhere in memory)          |
| **Access Time**        | Direct access via index ‚Äî O(1)                        | Sequential access ‚Äî O(n)                                      |
| **Insertion**          | Expensive (may shift elements) ‚Äî O(n)                 | Fast (just change pointers) ‚Äî O(1) if inserting at head       |
| **Deletion**           | Expensive (may shift elements) ‚Äî O(n)                 | Fast (just relink pointers) ‚Äî O(1) if node reference is known |
| **Search**             | O(n) unless indexed lookup                            | O(n) traversal                                                |
| **Memory Overhead**    | Less (only data)                                      | More (data + pointer for each node)                           |
| **Implementation**     | Simple, built-in in JS (`[]` or `Array`)              | Must be implemented using `class` and `Node` structure        |
| **Random Access**      | Supported (`arr[2]`)                                  | Not supported                                                 |
| **Dynamic Resizing**   | Possible but may require copying (in other languages) | Naturally dynamic                                             |
| **Cache Friendliness** | High (due to contiguous memory)                       | Low (due to scattered nodes)                                  |

## üí° Tip

Use **Arrays** when you need fast index-based access.\
Use **Linked Lists** when you need flexibility in adding/removing
elements.


## UseCase of Array and Linked List
| Situation / Use Case                      | Best Choice            | Reason                               |
| ----------------------------------------- | ---------------------- | ------------------------------------ |
| Random access (by index)                  | **Array**              | Direct index-based access (O(1))     |
| Frequent insertions/deletions             | **Linked List**        | No element shifting needed           |
| Fixed-size collection                     | **Array**              | Simpler, low memory overhead         |
| Dynamic / unpredictable size              | **Linked List**        | Easy to grow or shrink               |
| Heavy search operations                   | **Array**              | Better for indexing or binary search |
| Implementing stack or queue               | **Linked List**        | Efficient enqueue/dequeue            |
| Undo/Redo or history feature              | **Doubly Linked List** | Traverse both directions             |
| Data stored contiguously (cache-friendly) | **Array**              | Better CPU cache performance         |



